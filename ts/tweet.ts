class Tweet {
	private text:string;
	time:Date;

	constructor(tweet_text:string, tweet_time:string) {
        this.text = tweet_text;
		this.time = new Date(tweet_time);//, "ddd MMM D HH:mm:ss Z YYYY"
	}

	//returns either 'live_event', 'achievement', 'completed_event', or 'miscellaneous'
    get source():string {
        const t = this.text;
        const lower = t.toLowerCase();
        // Heuristics based on common RunKeeper templates
        if (lower.includes('just completed') || lower.includes('completed a ') || lower.includes('completed an ') || lower.includes('just posted') || lower.includes('just finished')) {
            return 'completed_event';
        }
        if (lower.includes('achieved') || lower.includes('achievement') || lower.includes('new personal record') || lower.includes('personal record') || lower.includes('goal')) {
            return 'achievement';
        }
        if (lower.includes("i'm") || lower.includes('i am ') || lower.includes('live ') || lower.includes('currently ') || lower.includes('right now')) {
            return 'live_event';
        }
        return 'miscellaneous';
    }

    //returns a boolean, whether the text includes any content written by the person tweeting.
    get written():boolean {
        // Remove link(s) and hashtag
        const base = this.text
            .replace(/https?:\/\/\S+/gi, '')
            .replace(/#RunKeeper/gi, '')
            .trim();
        // Identify common autogenerated phrases to strip
        const commonAutoPhrases: RegExp[] = [
            /just completed[^.]*$/i,
            /just completed[^-]*-?/i,
            /just finished[^-]*-?/i,
            /just posted[^-]*-?/i,
            /completed a [^.-]+/i,
            /completed an [^.-]+/i,
            /achieved[^.]+/i,
            /new personal record[^.]+/i,
            /with runkeeper/i,
        ];
        let stripped = base;
        commonAutoPhrases.forEach((re) => {
            stripped = stripped.replace(re, '');
        });
        // Remove residual punctuation and whitespace
        stripped = stripped.replace(/[\-–—•|]+/g, ' ').replace(/\s+/g, ' ').trim();
        // If any alphanumeric content remains, consider it written
        return /[a-z0-9]/i.test(stripped);
    }

    get writtenText():string {
        if(!this.written) {
            return "";
        }
        // Build a cleaned version and attempt to isolate user text
        let cleaned = this.text
            .replace(/https?:\/\/\S+/gi, '')
            .replace(/#RunKeeper/gi, '')
            .trim();
        // Remove leading common templates
        cleaned = cleaned
            .replace(/^(just completed[^-]*-?)/i, '')
            .replace(/^(just finished[^-]*-?)/i, '')
            .replace(/^(just posted[^-]*-?)/i, '')
            .replace(/^(completed a [^.-]+)/i, '')
            .replace(/^(completed an [^.-]+)/i, '')
            .replace(/with runkeeper/i, '')
            .trim();
        // Normalize spaces and punctuation
        cleaned = cleaned.replace(/[\-–—•|]+/g, ' ').replace(/\s+/g, ' ').trim();
        return cleaned;
    }

    get activityType():string {
        if (this.source != 'completed_event') {
            return "unknown";
        }
        // Look for pattern like "5.2 mi Run" or "10 km Walk"
        const lower = this.text.toLowerCase();
        const match = lower.match(/\b\d+(?:\.\d+)?\s*(mi|mile|miles|km|kilometer|kilometers)\s*([a-z]+)/i);
        if (match && match[2]) {
            return match[2].toLowerCase();
        }
        // Fallback: look for common activity words
        const activities = ['run', 'running', 'walk', 'walking', 'bike', 'biking', 'cycle', 'cycling', 'hike', 'hiking', 'swim', 'swimming', 'ski', 'skiing'];
        for (const a of activities) {
            if (lower.includes(a)) {
                return a;
            }
        }
        return "unknown";
    }

    get distance():number {
        if(this.source != 'completed_event') {
            return 0;
        }
        // Parse distance with units and convert to miles if needed
        const lower = this.text.toLowerCase();
        const m = lower.match(/\b(\d+(?:\.\d+)?)\s*(mi|mile|miles|km|kilometer|kilometers)\b/i);
        if (!m) {
            return 0;
        }
        const value = parseFloat(m[1]);
        const unit = m[2];
        if (['mi', 'mile', 'miles'].includes(unit)) {
            return value;
        }
        // kilometers -> miles
        return value / 1.609;
    }

    getHTMLTableRow(rowNumber:number):string {
        // Convert URLs to clickable links
        const htmlTweet = this.text.replace(/(https?:\/\/\S+)/g, '<a href="$1" target="_blank">$1<\/a>');
        const activity = this.activityType;
        return `<tr><th scope="row">${rowNumber}<\/th><td>${activity}<\/td><td>${htmlTweet}<\/td><\/tr>`;
    }
}